<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "./pbr"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package pbr implements Physically-Based Rendering with a Monte Carlo path tracer.
</p>
<p>
Scene holds various renderable Surfaces.
Camera specifies a point-of-view for rendering a Scene.
Surface describes surfaces like spheres and cubes.
Sampler samples pixels in a Scene from a particular Camera.
Renderer renders samples into Images.
Cli provides an easy mechanism for Rendering PNG files from a terminal.
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
			
				
				<dd><a href="#Camera">type Camera</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera35mm">func Camera35mm(width, height int, lens float64) *Camera</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.Focus">func (c *Camera) Focus(x, y, z, fStop float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.LookAt">func (c *Camera) LookAt(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.MoveTo">func (c *Camera) MoveTo(x, y, z float64)</a></dd>
				
			
				
				<dd><a href="#Cli">type Cli</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CliRunner">func CliRunner(scene *Scene, cam *Camera, renderer *Renderer) Cli</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Cli.Render">func (c Cli) Render()</a></dd>
				
			
				
				<dd><a href="#Cube">type Cube</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnitCube">func UnitCube(pos Matrix4, mat Material) *Cube</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Cube.Intersect">func (c *Cube) Intersect(ray Ray3) (bool, float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Cube.MaterialAt">func (c *Cube) MaterialAt(v Vector3) Material</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Cube.NormalAt">func (c *Cube) NormalAt(p Vector3) Vector3</a></dd>
				
			
				
				<dd><a href="#Hit">type Hit</a></dd>
				
				
			
				
				<dd><a href="#Material">type Material</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DayLight">func DayLight() Material</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Glass">func Glass(r, g, b, opacity float64, gloss float64) Material</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Light">func Light(r, g, b float64) Material</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Metal">func Metal(r, g, b float64, gloss float64) Material</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Plastic">func Plastic(r, g, b float64, gloss float64) Material</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Material.Bsdf">func (m *Material) Bsdf(normal Vector3, incident Vector3, dist float64, rnd *rand.Rand) (next bool, dir Vector3, signal Vector3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Material.Emit">func (m *Material) Emit(normal Vector3, dir Vector3) Vector3</a></dd>
				
			
				
				<dd><a href="#Matrix4">type Matrix4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Ident">func Ident() Matrix4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LookMatrix">func LookMatrix(o Vector3, to Vector3) Matrix4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMatrix4">func NewMatrix4(a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4 float64) (m Matrix4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rotation">func Rotation(v Vector3) Matrix4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scale">func Scale(x, y, z float64) Matrix4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Translation">func Translation(x, y, z float64) Matrix4</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Matrix4.Inverse">func (a *Matrix4) Inverse() *Matrix4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matrix4.Mult">func (a Matrix4) Mult(b Matrix4) (result Matrix4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matrix4.MultDir">func (a Matrix4) MultDir(v Vector3) (result Vector3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matrix4.MultNormal">func (a Matrix4) MultNormal(v Vector3) (result Vector3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matrix4.MultPoint">func (a Matrix4) MultPoint(v Vector3) (result Vector3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matrix4.MultRay">func (a Matrix4) MultRay(r Ray3) (result Ray3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matrix4.Rot">func (a Matrix4) Rot(v Vector3) Matrix4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matrix4.Scale">func (a Matrix4) Scale(x, y, z float64) Matrix4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matrix4.Trans">func (a Matrix4) Trans(x, y, z float64) Matrix4</a></dd>
				
			
				
				<dd><a href="#RGBAE">type RGBAE</a></dd>
				
				
			
				
				<dd><a href="#Ray3">type Ray3</a></dd>
				
				
			
				
				<dd><a href="#Renderer">type Renderer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CamRenderer">func CamRenderer(cam *Camera, exp float64) *Renderer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Renderer.Heat">func (r *Renderer) Heat() image.Image</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Renderer.Merge">func (r *Renderer) Merge(pixels []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Renderer.Rgb">func (r *Renderer) Rgb() image.Image</a></dd>
				
			
				
				<dd><a href="#Sampler">type Sampler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSampler">func NewSampler(cam *Camera, scene *Scene, bounces int, adapt int) *Sampler</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Sampler.Pixels">func (s *Sampler) Pixels() []float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Sampler.Sample">func (s *Sampler) Sample(p int, rnd *rand.Rand, samples int) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Sampler.SampleFrame">func (s *Sampler) SampleFrame() (total int)</a></dd>
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EmptyScene">func EmptyScene() *Scene</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.Add">func (s *Scene) Add(surfaces ...Surface)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.Env">func (s *Scene) Env(ray Ray3) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.Intersect">func (s *Scene) Intersect(ray Ray3) (hit Hit)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.SetEnv">func (s *Scene) SetEnv(file string, expose float64)</a></dd>
				
			
				
				<dd><a href="#Sphere">type Sphere</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnitSphere">func UnitSphere(pos Matrix4, mat Material) *Sphere</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Sphere.Intersect">func (s *Sphere) Intersect(ray Ray3) (hit bool, dist float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Sphere.MaterialAt">func (s *Sphere) MaterialAt(v Vector3) Material</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Sphere.NormalAt">func (s *Sphere) NormalAt(point Vector3) Vector3</a></dd>
				
			
				
				<dd><a href="#Surface">type Surface</a></dd>
				
				
			
				
				<dd><a href="#Vector3">type Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AngleVector">func AngleVector(theta, phi float64) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SphereVector">func SphereVector(rnd *rand.Rand) Vector3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Abs">func (a Vector3) Abs() Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Array">func (a Vector3) Array() [3]float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Ave">func (a Vector3) Ave() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.By">func (a Vector3) By(b Vector3) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Cone">func (a Vector3) Cone(size float64, rnd *rand.Rand) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Cross">func (a Vector3) Cross(b Vector3) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Dot">func (a Vector3) Dot(b Vector3) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Enters">func (a Vector3) Enters(b Vector3) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Equals">func (a Vector3) Equals(b Vector3) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Len">func (a Vector3) Len() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Lerp">func (a Vector3) Lerp(b Vector3, n float64) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Max">func (a Vector3) Max() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Minus">func (a Vector3) Minus(b Vector3) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Plus">func (a Vector3) Plus(b Vector3) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.RandHemiCos">func (a Vector3) RandHemiCos(rnd *rand.Rand) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Reflected">func (a Vector3) Reflected(b Vector3) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Refracted">func (a Vector3) Refracted(b Vector3, indexA, indexB float64) (bool, Vector3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Scaled">func (a Vector3) Scaled(n float64) Vector3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vector3.Unit">func (a Vector3) Unit() Vector3</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/target/camera.go">camera.go</a>
			
				<a href="/src/target/cli.go">cli.go</a>
			
				<a href="/src/target/constants.go">constants.go</a>
			
				<a href="/src/target/cube.go">cube.go</a>
			
				<a href="/src/target/doc.go">doc.go</a>
			
				<a href="/src/target/hit.go">hit.go</a>
			
				<a href="/src/target/material.go">material.go</a>
			
				<a href="/src/target/matrix4.go">matrix4.go</a>
			
				<a href="/src/target/ray3.go">ray3.go</a>
			
				<a href="/src/target/renderer.go">renderer.go</a>
			
				<a href="/src/target/sampler.go">sampler.go</a>
			
				<a href="/src/target/scene.go">scene.go</a>
			
				<a href="/src/target/sphere.go">sphere.go</a>
			
				<a href="/src/target/surface.go">surface.go</a>
			
				<a href="/src/target/vector3.go">vector3.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>
Pixel elements are stored in specific offsets.
These constants allow easy access, eg `someFloat64Array[i + Blue]`
</p>

				<pre>const (
    <span id="Red">Red</span>      = 0
    <span id="Green">Green</span>    = 1
    <span id="Blue">Blue</span>     = 2
    <span id="Count">Count</span>    = 3
    <span id="Noise">Noise</span>    = 4
    <span id="Elements">Elements</span> = 5
)</pre>
			
				<p>
Bias is the minimum distance unit.
Applying bias provides more robust processing of geometry.
</p>

				<pre>const <span id="Bias">Bias</span> = 1e-6</pre>
			
		
		
		
		
			
			
			<h2 id="Camera">type <a href="/src/target/camera.go?s=233:391#L1">Camera</a>
				<a class="permalink" href="#Camera">&#xb6;</a>
			</h2>
			<p>
Camera generates rays from a simulated physical camera into a Scene.
The rays produced are determined by position,
orientation, sensor type, focus, exposure, and lens selection.
</p>

			<pre>type Camera struct {
<span id="Camera.Width"></span>    Width  <a href="/pkg/builtin/#int">int</a>
<span id="Camera.Height"></span>    Height <a href="/pkg/builtin/#int">int</a>
<span id="Camera.Lens"></span>    Lens   <a href="/pkg/builtin/#float64">float64</a>
<span id="Camera.Sensor"></span>    Sensor <a href="/pkg/builtin/#float64">float64</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="Camera35mm">func <a href="/src/target/camera.go?s=445:501#L14">Camera35mm</a>
					<a class="permalink" href="#Camera35mm">&#xb6;</a>
				</h3>
				<pre>func Camera35mm(width, height <a href="/pkg/builtin/#int">int</a>, lens <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Camera">Camera</a></pre>
				<p>
Camera35mm makes a new Full-frame (35mm) camera.
</p>

				
				
			

			
				
				<h3 id="Camera.Focus">func (*Camera) <a href="/src/target/camera.go?s=955:1001#L36">Focus</a>
					<a class="permalink" href="#Camera.Focus">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Camera">Camera</a>) Focus(x, y, z, fStop <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Focus on a point
</p>

				
				
				
			
				
				<h3 id="Camera.LookAt">func (*Camera) <a href="/src/target/camera.go?s=674:714#L24">LookAt</a>
					<a class="permalink" href="#Camera.LookAt">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Camera">Camera</a>) LookAt(x, y, z <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
LookAt orients the camera
</p>

				
				
				
			
				
				<h3 id="Camera.MoveTo">func (*Camera) <a href="/src/target/camera.go?s=820:860#L30">MoveTo</a>
					<a class="permalink" href="#Camera.MoveTo">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Camera">Camera</a>) MoveTo(x, y, z <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
MoveTo positions the camera
</p>

				
				
				
			
		
			
			
			<h2 id="Cli">type <a href="/src/target/cli.go?s=200:274#L8">Cli</a>
				<a class="permalink" href="#Cli">&#xb6;</a>
			</h2>
			<p>
Cli is an abstraction for executing a render via a terminal.
</p>

			<pre>type Cli struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="CliRunner">func <a href="/src/target/cli.go?s=406:471#L20">CliRunner</a>
					<a class="permalink" href="#CliRunner">&#xb6;</a>
				</h3>
				<pre>func CliRunner(scene *<a href="#Scene">Scene</a>, cam *<a href="#Camera">Camera</a>, renderer *<a href="#Renderer">Renderer</a>) <a href="#Cli">Cli</a></pre>
				<p>
CliRunner constructs a CLI from pointers to a scene, camera, and renderer.
</p>

				
				
			

			
				
				<h3 id="Cli.Render">func (Cli) <a href="/src/target/cli.go?s=896:917#L30">Render</a>
					<a class="permalink" href="#Cli.Render">&#xb6;</a>
				</h3>
				<pre>func (c <a href="#Cli">Cli</a>) Render()</pre>
				<p>
Render parses command-line flags and creates
workers to render its given scene, in parallel, from the point-of-view of its given camera.
Unless given a -samples argument, it renders increasingly high-fidelity images
until it&#39;s interrupted by a signal (like SIGINT / Ctrl+C).
Once it receives a signal or passes its sampling threshold, it writes results to PNGs.
</p>

				
				
				
			
		
			
			
			<h2 id="Cube">type <a href="/src/target/cube.go?s=103:150#L1">Cube</a>
				<a class="permalink" href="#Cube">&#xb6;</a>
			</h2>
			<p>
Cube describes a unit cube scaled, rotated, and translated by Pos.
</p>

			<pre>type Cube struct {
<span id="Cube.Pos"></span>    Pos <a href="#Matrix4">Matrix4</a>
<span id="Cube.Mat"></span>    Mat <a href="#Material">Material</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="UnitCube">func <a href="/src/target/cube.go?s=246:292#L4">UnitCube</a>
					<a class="permalink" href="#UnitCube">&#xb6;</a>
				</h3>
				<pre>func UnitCube(pos <a href="#Matrix4">Matrix4</a>, mat <a href="#Material">Material</a>) *<a href="#Cube">Cube</a></pre>
				<p>
UnitCube returns a pointer to a new 1x1x1 Cube Surface with position pos and material mat.
</p>

				
				
			

			
				
				<h3 id="Cube.Intersect">func (*Cube) <a href="/src/target/cube.go?s=768:818#L16">Intersect</a>
					<a class="permalink" href="#Cube.Intersect">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Cube">Cube</a>) Intersect(ray <a href="#Ray3">Ray3</a>) (<a href="/pkg/builtin/#bool">bool</a>, <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Intersect tests for an intersection between a Ray3 and this Cube
It returns whether there was an intersection (bool) and the intersection distance along the ray (float64)
Both the Ray3 and the distance are in world space.
<a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection">https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection</a>
<a href="https://tavianator.com/fast-branchless-raybounding-box-intersections/">https://tavianator.com/fast-branchless-raybounding-box-intersections/</a>
</p>

				
				
				
			
				
				<h3 id="Cube.MaterialAt">func (*Cube) <a href="/src/target/cube.go?s=2166:2211#L61">MaterialAt</a>
					<a class="permalink" href="#Cube.MaterialAt">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Cube">Cube</a>) MaterialAt(v <a href="#Vector3">Vector3</a>) <a href="#Material">Material</a></pre>
				<p>
MaterialAt returns the Material at this point on the Surface
</p>

				
				
				
			
				
				<h3 id="Cube.NormalAt">func (*Cube) <a href="/src/target/cube.go?s=1593:1635#L44">NormalAt</a>
					<a class="permalink" href="#Cube.NormalAt">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Cube">Cube</a>) NormalAt(p <a href="#Vector3">Vector3</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
NormalAt returns the normal Vector3 at this point on the Surface
</p>

				
				
				
			
		
			
			
			<h2 id="Hit">type <a href="/src/target/hit.go?s=75:379#L1">Hit</a>
				<a class="permalink" href="#Hit">&#xb6;</a>
			</h2>
			<p>
Hit describes an intersection between a Ray3 and a Surface
</p>

			<pre>type Hit struct {
<span id="Hit.Normal"></span>    Normal <a href="#Vector3">Vector3</a>  <span class="comment">// The Normal of the Surface at the intersection point</span>
<span id="Hit.Mat"></span>    Mat    <a href="#Material">Material</a> <span class="comment">// The Material of the Surface at the intersection point</span>
<span id="Hit.Dist"></span>    Dist   <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// The Distance along the Ray3 where the intersection occurs</span>
<span id="Hit.Point"></span>    Point  <a href="#Vector3">Vector3</a>  <span class="comment">// The point of intersection in world space</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Material">type <a href="/src/target/material.go?s=114:632#L1">Material</a>
				<a class="permalink" href="#Material">&#xb6;</a>
			</h2>
			<p>
Material describes the properties of a physically-based material
</p>

			<pre>type Material struct {
<span id="Material.Color"></span>    Color   <a href="#Vector3">Vector3</a> <span class="comment">// Albedo color, used for diffuse light</span>
<span id="Material.Fresnel"></span>    Fresnel <a href="#Vector3">Vector3</a> <span class="comment">// Fresnel coefficients, used for fresnel reflectivity</span>
<span id="Material.Light"></span>    Light   <a href="#Vector3">Vector3</a> <span class="comment">// Light emittance, used if this Material is a light source</span>
<span id="Material.Refract"></span>    Refract <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Index of refraction</span>
<span id="Material.Opacity"></span>    Opacity <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Amount of light transmitted through this Material</span>
<span id="Material.Gloss"></span>    Gloss   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Microsurface roughness (how &#34;polished&#34; is this Material)</span>
<span id="Material.Metal"></span>    Metal   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// The metallic range of electric (1) or dielectric (0), controls energy absorption</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="DayLight">func <a href="/src/target/material.go?s=865:889#L16">DayLight</a>
					<a class="permalink" href="#DayLight">&#xb6;</a>
				</h3>
				<pre>func DayLight() <a href="#Material">Material</a></pre>
				<p>
DayLight constructs a new light with a DayLight color temperature.
</p>

				
				
			
				
				<h3 id="Glass">func <a href="/src/target/material.go?s=1822:1882#L48">Glass</a>
					<a class="permalink" href="#Glass">&#xb6;</a>
				</h3>
				<pre>func Glass(r, g, b, opacity <a href="/pkg/builtin/#float64">float64</a>, gloss <a href="/pkg/builtin/#float64">float64</a>) <a href="#Material">Material</a></pre>
				<p>
Glass constructs a new glass material
r, g, b (0-1) controls the color
opacity (0-1) controls how much light is transmitted through the glass
gloss (0-1) controls the microfacet roughness (how polished the surface looks)
</p>

				
				
			
				
				<h3 id="Light">func <a href="/src/target/material.go?s=711:747#L11">Light</a>
					<a class="permalink" href="#Light">&#xb6;</a>
				</h3>
				<pre>func Light(r, g, b <a href="/pkg/builtin/#float64">float64</a>) <a href="#Material">Material</a></pre>
				<p>
Light constructs a new light
r, g, b (0-Inf) specifies the light color
</p>

				
				
			
				
				<h3 id="Metal">func <a href="/src/target/material.go?s=1436:1487#L35">Metal</a>
					<a class="permalink" href="#Metal">&#xb6;</a>
				</h3>
				<pre>func Metal(r, g, b <a href="/pkg/builtin/#float64">float64</a>, gloss <a href="/pkg/builtin/#float64">float64</a>) <a href="#Material">Material</a></pre>
				<p>
Metal constructs a new metal material
r, g, b (0-1) controls the fresnel color
gloss (0-1) controls the microfacet roughness (how polished the surface looks)
</p>

				
				
			
				
				<h3 id="Plastic">func <a href="/src/target/material.go?s=1090:1143#L23">Plastic</a>
					<a class="permalink" href="#Plastic">&#xb6;</a>
				</h3>
				<pre>func Plastic(r, g, b <a href="/pkg/builtin/#float64">float64</a>, gloss <a href="/pkg/builtin/#float64">float64</a>) <a href="#Material">Material</a></pre>
				<p>
Plastic constructs a new plastic material
r, g, b (0-1) controls the color
gloss (0-1) controls the microfacet roughness (how polished the surface looks)
</p>

				
				
			

			
				
				<h3 id="Material.Bsdf">func (*Material) <a href="/src/target/material.go?s=2135:2263#L60">Bsdf</a>
					<a class="permalink" href="#Material.Bsdf">&#xb6;</a>
				</h3>
				<pre>func (m *<a href="#Material">Material</a>) Bsdf(normal <a href="#Vector3">Vector3</a>, incident <a href="#Vector3">Vector3</a>, dist <a href="/pkg/builtin/#float64">float64</a>, rnd *<a href="/pkg/math/rand/">rand</a>.<a href="/pkg/math/rand/#Rand">Rand</a>) (next <a href="/pkg/builtin/#bool">bool</a>, dir <a href="#Vector3">Vector3</a>, signal <a href="#Vector3">Vector3</a>)</pre>
				<p>
Bsdf returns next rays predicted by the Material&#39;s
Bidirectional Scattering Distribution Function
</p>

				
				
				
			
				
				<h3 id="Material.Emit">func (*Material) <a href="/src/target/material.go?s=3157:3217#L88">Emit</a>
					<a class="permalink" href="#Material.Emit">&#xb6;</a>
				</h3>
				<pre>func (m *<a href="#Material">Material</a>) Emit(normal <a href="#Vector3">Vector3</a>, dir <a href="#Vector3">Vector3</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
Emit returns the amount of light emitted
from the Material at a given angle
</p>

				
				
				
			
		
			
			
			<h2 id="Matrix4">type <a href="/src/target/matrix4.go?s=279:335#L4">Matrix4</a>
				<a class="permalink" href="#Matrix4">&#xb6;</a>
			</h2>
			<p>
Matrix4 handles matrix data and operations
Column-major (as in math and Direct3D)
<a href="https://fgiesen.wordpress.com/2012/02/12/row-major-vs-column-major-row-vectors-vs-column-vectors/">https://fgiesen.wordpress.com/2012/02/12/row-major-vs-column-major-row-vectors-vs-column-vectors/</a>
</p>

			<pre>type Matrix4 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="Ident">func <a href="/src/target/matrix4.go?s=673:693#L21">Ident</a>
					<a class="permalink" href="#Ident">&#xb6;</a>
				</h3>
				<pre>func Ident() <a href="#Matrix4">Matrix4</a></pre>
				<p>
Ident creates a new identity matrix
</p>

				
				
			
				
				<h3 id="LookMatrix">func <a href="/src/target/matrix4.go?s=1163:1209#L35">LookMatrix</a>
					<a class="permalink" href="#LookMatrix">&#xb6;</a>
				</h3>
				<pre>func LookMatrix(o <a href="#Vector3">Vector3</a>, to <a href="#Vector3">Vector3</a>) <a href="#Matrix4">Matrix4</a></pre>
				<p>
LookMatrix creates a matrix looking from `from` towards `to`
<a href="http://www.cs.virginia.edu/~gfx/courses/1999/intro.fall99.html/lookat.html">http://www.cs.virginia.edu/~gfx/courses/1999/intro.fall99.html/lookat.html</a>
<a href="https://www.3dgep.com/understanding-the-view-matrix/#Look_At_Camera">https://www.3dgep.com/understanding-the-view-matrix/#Look_At_Camera</a>
<a href="http://www.codinglabs.net/article_world_view_projection_matrix.aspx">http://www.codinglabs.net/article_world_view_projection_matrix.aspx</a>
<a href="https://fgiesen.wordpress.com/2012/02/12/row-major-vs-column-major-row-vectors-vs-column-vectors/">https://fgiesen.wordpress.com/2012/02/12/row-major-vs-column-major-row-vectors-vs-column-vectors/</a>
</p>

				
				
			
				
				<h3 id="NewMatrix4">func <a href="/src/target/matrix4.go?s=375:474#L10">NewMatrix4</a>
					<a class="permalink" href="#NewMatrix4">&#xb6;</a>
				</h3>
				<pre>func NewMatrix4(a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4 <a href="/pkg/builtin/#float64">float64</a>) (m <a href="#Matrix4">Matrix4</a>)</pre>
				<p>
NewMatrix4 constructs a new matrix
</p>

				
				
			
				
				<h3 id="Rotation">func <a href="/src/target/matrix4.go?s=1969:2001#L70">Rotation</a>
					<a class="permalink" href="#Rotation">&#xb6;</a>
				</h3>
				<pre>func Rotation(v <a href="#Vector3">Vector3</a>) <a href="#Matrix4">Matrix4</a></pre>
				<p>
Rotation creates a rotation matrix from an angle-axis Vector representation
<a href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToMatrix/">http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToMatrix/</a>
</p>

				
				
			
				
				<h3 id="Scale">func <a href="/src/target/matrix4.go?s=1685:1720#L59">Scale</a>
					<a class="permalink" href="#Scale">&#xb6;</a>
				</h3>
				<pre>func Scale(x, y, z <a href="/pkg/builtin/#float64">float64</a>) <a href="#Matrix4">Matrix4</a></pre>
				<p>
Scale creates a new scaling matrix
</p>

				
				
			
				
				<h3 id="Translation">func <a href="/src/target/matrix4.go?s=1521:1562#L49">Translation</a>
					<a class="permalink" href="#Translation">&#xb6;</a>
				</h3>
				<pre>func Translation(x, y, z <a href="/pkg/builtin/#float64">float64</a>) <a href="#Matrix4">Matrix4</a></pre>
				<p>
Translation creates a new translation matrix
</p>

				
				
			

			
				
				<h3 id="Matrix4.Inverse">func (*Matrix4) <a href="/src/target/matrix4.go?s=4242:4278#L146">Inverse</a>
					<a class="permalink" href="#Matrix4.Inverse">&#xb6;</a>
				</h3>
				<pre>func (a *<a href="#Matrix4">Matrix4</a>) Inverse() *<a href="#Matrix4">Matrix4</a></pre>
				<p>
Inverse returns the inverse of this matrix
<a href="https://www.gamedev.net/forums/topic/648190-algorithm-for-4x4-matrix-inverse/">https://www.gamedev.net/forums/topic/648190-algorithm-for-4x4-matrix-inverse/</a>
<a href="https://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix">https://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix</a>
</p>

				
				
				
			
				
				<h3 id="Matrix4.Mult">func (Matrix4) <a href="/src/target/matrix4.go?s=2673:2722#L102">Mult</a>
					<a class="permalink" href="#Matrix4.Mult">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Matrix4">Matrix4</a>) Mult(b <a href="#Matrix4">Matrix4</a>) (result <a href="#Matrix4">Matrix4</a>)</pre>
				<p>
Mult multiplies by another matrix4
TODO: a and b might be flipped here
</p>

				
				
				
			
				
				<h3 id="Matrix4.MultDir">func (Matrix4) <a href="/src/target/matrix4.go?s=3346:3398#L123">MultDir</a>
					<a class="permalink" href="#Matrix4.MultDir">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Matrix4">Matrix4</a>) MultDir(v <a href="#Vector3">Vector3</a>) (result <a href="#Vector3">Vector3</a>)</pre>
				<p>
MultDir multiplies this matrix4 by a vector, excluding translation
</p>

				
				
				
			
				
				<h3 id="Matrix4.MultNormal">func (Matrix4) <a href="/src/target/matrix4.go?s=3678:3733#L131">MultNormal</a>
					<a class="permalink" href="#Matrix4.MultNormal">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Matrix4">Matrix4</a>) MultNormal(v <a href="#Vector3">Vector3</a>) (result <a href="#Vector3">Vector3</a>)</pre>
				<p>
MultNormal multiplies this matrix4 by a normal vector, renormalizing the result
</p>

				
				
				
			
				
				<h3 id="Matrix4.MultPoint">func (Matrix4) <a href="/src/target/matrix4.go?s=2948:3002#L114">MultPoint</a>
					<a class="permalink" href="#Matrix4.MultPoint">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Matrix4">Matrix4</a>) MultPoint(v <a href="#Vector3">Vector3</a>) (result <a href="#Vector3">Vector3</a>)</pre>
				<p>
MultPoint multiplies this matrix4 by a vector, including translation
</p>

				
				
				
			
				
				<h3 id="Matrix4.MultRay">func (Matrix4) <a href="/src/target/matrix4.go?s=3912:3958#L137">MultRay</a>
					<a class="permalink" href="#Matrix4.MultRay">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Matrix4">Matrix4</a>) MultRay(r <a href="#Ray3">Ray3</a>) (result <a href="#Ray3">Ray3</a>)</pre>
				<p>
MultRay multiplies this matrix by a ray
<a href="https://gamedev.stackexchange.com/questions/72440/the-correct-way-to-transform-a-ray-with-a-matrix">https://gamedev.stackexchange.com/questions/72440/the-correct-way-to-transform-a-ray-with-a-matrix</a>
</p>

				
				
				
			
				
				<h3 id="Matrix4.Rot">func (Matrix4) <a href="/src/target/matrix4.go?s=2523:2562#L96">Rot</a>
					<a class="permalink" href="#Matrix4.Rot">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Matrix4">Matrix4</a>) Rot(v <a href="#Vector3">Vector3</a>) <a href="#Matrix4">Matrix4</a></pre>
				<p>
Rot is a chaining rotation
</p>

				
				
				
			
				
				<h3 id="Matrix4.Scale">func (Matrix4) <a href="/src/target/matrix4.go?s=2409:2456#L91">Scale</a>
					<a class="permalink" href="#Matrix4.Scale">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Matrix4">Matrix4</a>) Scale(x, y, z <a href="/pkg/builtin/#float64">float64</a>) <a href="#Matrix4">Matrix4</a></pre>
				<p>
Scale is a chaining scale
</p>

				
				
				
			
				
				<h3 id="Matrix4.Trans">func (Matrix4) <a href="/src/target/matrix4.go?s=2290:2337#L86">Trans</a>
					<a class="permalink" href="#Matrix4.Trans">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Matrix4">Matrix4</a>) Trans(x, y, z <a href="/pkg/builtin/#float64">float64</a>) <a href="#Matrix4">Matrix4</a></pre>
				<p>
Trans is a chaining translation
</p>

				
				
				
			
		
			
			
			<h2 id="RGBAE">type <a href="/src/target/scene.go?s=106:185#L1">RGBAE</a>
				<a class="permalink" href="#RGBAE">&#xb6;</a>
			</h2>
			<p>
RGBAE Describes an rgbae (hdr) image
</p>

			<pre>type RGBAE struct {
<span id="RGBAE.Width"></span>    Width  <a href="/pkg/builtin/#int">int</a>
<span id="RGBAE.Height"></span>    Height <a href="/pkg/builtin/#int">int</a>
<span id="RGBAE.Data"></span>    Data   []<a href="/pkg/builtin/#float32">float32</a>
<span id="RGBAE.Expose"></span>    Expose <a href="/pkg/builtin/#float64">float64</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Ray3">type <a href="/src/target/ray3.go?s=96:148#L1">Ray3</a>
				<a class="permalink" href="#Ray3">&#xb6;</a>
			</h2>
			<p>
Ray3 describes a 3-dimensional ray with an origin and a unit direction Vector3.
</p>

			<pre>type Ray3 struct {
<span id="Ray3.Origin"></span>    Origin <a href="#Vector3">Vector3</a>
<span id="Ray3.Dir"></span>    Dir    <a href="#Vector3">Vector3</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Renderer">type <a href="/src/target/renderer.go?s=95:185#L1">Renderer</a>
				<a class="permalink" href="#Renderer">&#xb6;</a>
			</h2>
			<p>
Renderer renders the results of a trace to a file
</p>

			<pre>type Renderer struct {
<span id="Renderer.Width"></span>    Width    <a href="/pkg/builtin/#int">int</a>
<span id="Renderer.Height"></span>    Height   <a href="/pkg/builtin/#int">int</a>
<span id="Renderer.Exposure"></span>    Exposure <a href="/pkg/builtin/#float64">float64</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="CamRenderer">func <a href="/src/target/renderer.go?s=237:289#L7">CamRenderer</a>
					<a class="permalink" href="#CamRenderer">&#xb6;</a>
				</h3>
				<pre>func CamRenderer(cam *<a href="#Camera">Camera</a>, exp <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Renderer">Renderer</a></pre>
				<p>
CamRenderer sizes a Renderer to match a Camera
</p>

				
				
			

			
				
				<h3 id="Renderer.Heat">func (*Renderer) <a href="/src/target/renderer.go?s=1184:1221#L42">Heat</a>
					<a class="permalink" href="#Renderer.Heat">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Renderer">Renderer</a>) Heat() <a href="/pkg/image/">image</a>.<a href="/pkg/image/#Image">Image</a></pre>
				<p>
Heat returns a heatmap of the sample count for each pixel
</p>

				
				
				
			
				
				<h3 id="Renderer.Merge">func (*Renderer) <a href="/src/target/renderer.go?s=442:484#L17">Merge</a>
					<a class="permalink" href="#Renderer.Merge">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Renderer">Renderer</a>) Merge(pixels []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Merge merges pixel arrays
</p>

				
				
				
			
				
				<h3 id="Renderer.Rgb">func (*Renderer) <a href="/src/target/renderer.go?s=735:771#L28">Rgb</a>
					<a class="permalink" href="#Renderer.Rgb">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Renderer">Renderer</a>) Rgb() <a href="/pkg/image/">image</a>.<a href="/pkg/image/#Image">Image</a></pre>
				<p>
Rgb averages each sample into an rgb value
TODO: better to return image.Image or *image.Image? Tradeoffs?
</p>

				
				
				
			
		
			
			
			<h2 id="Sampler">type <a href="/src/target/sampler.go?s=123:318#L1">Sampler</a>
				<a class="permalink" href="#Sampler">&#xb6;</a>
			</h2>
			<p>
Sampler samples pixels for a Scene by tracing Rays from a Camera.
</p>

			<pre>type Sampler struct {
<span id="Sampler.Width"></span>    Width  <a href="/pkg/builtin/#int">int</a>
<span id="Sampler.Height"></span>    Height <a href="/pkg/builtin/#int">int</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewSampler">func <a href="/src/target/sampler.go?s=616:691#L16">NewSampler</a>
					<a class="permalink" href="#NewSampler">&#xb6;</a>
				</h3>
				<pre>func NewSampler(cam *<a href="#Camera">Camera</a>, scene *<a href="#Scene">Scene</a>, bounces <a href="/pkg/builtin/#int">int</a>, adapt <a href="/pkg/builtin/#int">int</a>) *<a href="#Sampler">Sampler</a></pre>
				<p>
NewSampler constructs a new Sampler instance.
The Sampler samples Rays from the Camera into the Scene.
bounces specifies the maximum number of times a Ray can bounce around the scene (eg, 10).
adapt specifies how adaptive sampling should be to noise (0 = none, 3 = medium, 4 = high).
</p>

				
				
			

			
				
				<h3 id="Sampler.Pixels">func (*Sampler) <a href="/src/target/sampler.go?s=2218:2254#L69">Pixels</a>
					<a class="permalink" href="#Sampler.Pixels">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#Sampler">Sampler</a>) Pixels() []<a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Pixels returns an array of float64 pixel values.
</p>

				
				
				
			
				
				<h3 id="Sampler.Sample">func (*Sampler) <a href="/src/target/sampler.go?s=1681:1749#L50">Sample</a>
					<a class="permalink" href="#Sampler.Sample">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#Sampler">Sampler</a>) Sample(p <a href="/pkg/builtin/#int">int</a>, rnd *<a href="/pkg/math/rand/">rand</a>.<a href="/pkg/math/rand/#Rand">Rand</a>, samples <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Sample samples a single pixel `samples` times.
The pixel is specified by the index `p`.
</p>

				
				
				
			
				
				<h3 id="Sampler.SampleFrame">func (*Sampler) <a href="/src/target/sampler.go?s=1103:1146#L31">SampleFrame</a>
					<a class="permalink" href="#Sampler.SampleFrame">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#Sampler">Sampler</a>) SampleFrame() (total <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
SampleFrame samples every pixel in the Camera&#39;s frame at least once.
Depending on the Sampler&#39;s `adapt` value, noisy pixels may be sampled several times.
It returns the total number of samples taken.
</p>

				
				
				
			
		
			
			
			<h2 id="Scene">type <a href="/src/target/scene.go?s=217:274#L9">Scene</a>
				<a class="permalink" href="#Scene">&#xb6;</a>
			</h2>
			<p>
Scene describes a 3d scene
</p>

			<pre>type Scene struct {
<span id="Scene.Surfaces"></span>    Surfaces []<a href="#Surface">Surface</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="EmptyScene">func <a href="/src/target/scene.go?s=339:363#L15">EmptyScene</a>
					<a class="permalink" href="#EmptyScene">&#xb6;</a>
				</h3>
				<pre>func EmptyScene() *<a href="#Scene">Scene</a></pre>
				<p>
EmptyScene creates and returns a pointer to an empty Scene.
</p>

				
				
			

			
				
				<h3 id="Scene.Add">func (*Scene) <a href="/src/target/scene.go?s=1485:1525#L57">Add</a>
					<a class="permalink" href="#Scene.Add">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#Scene">Scene</a>) Add(surfaces ...<a href="#Surface">Surface</a>)</pre>
				<p>
Add adds new Surfaces to the scene
</p>

				
				
				
			
				
				<h3 id="Scene.Env">func (*Scene) <a href="/src/target/scene.go?s=940:977#L41">Env</a>
					<a class="permalink" href="#Scene.Env">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#Scene">Scene</a>) Env(ray <a href="#Ray3">Ray3</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
Env returns the light value from the environment map
<a href="http://gl.ict.usc.edu/Data/HighResProbes/">http://gl.ict.usc.edu/Data/HighResProbes/</a>
</p>

				
				
				
			
				
				<h3 id="Scene.Intersect">func (*Scene) <a href="/src/target/scene.go?s=449:494#L20">Intersect</a>
					<a class="permalink" href="#Scene.Intersect">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#Scene">Scene</a>) Intersect(ray <a href="#Ray3">Ray3</a>) (hit <a href="#Hit">Hit</a>)</pre>
				<p>
Intersect tests whether a ray hits any objects in the scene
</p>

				
				
				
			
				
				<h3 id="Scene.SetEnv">func (*Scene) <a href="/src/target/scene.go?s=1612:1663#L62">SetEnv</a>
					<a class="permalink" href="#Scene.SetEnv">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#Scene">Scene</a>) SetEnv(file <a href="/pkg/builtin/#string">string</a>, expose <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
SetEnv sets the environment map
</p>

				
				
				
			
		
			
			
			<h2 id="Sphere">type <a href="/src/target/sphere.go?s=60:109#L1">Sphere</a>
				<a class="permalink" href="#Sphere">&#xb6;</a>
			</h2>
			<p>
Sphere describes a 3d sphere
</p>

			<pre>type Sphere struct {
<span id="Sphere.Pos"></span>    Pos <a href="#Matrix4">Matrix4</a>
<span id="Sphere.Mat"></span>    Mat <a href="#Material">Material</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="UnitSphere">func <a href="/src/target/sphere.go?s=209:259#L2">UnitSphere</a>
					<a class="permalink" href="#UnitSphere">&#xb6;</a>
				</h3>
				<pre>func UnitSphere(pos <a href="#Matrix4">Matrix4</a>, mat <a href="#Material">Material</a>) *<a href="#Sphere">Sphere</a></pre>
				<p>
UnitSphere returns a pointer to a new 1x1x1 Sphere Surface with position pos and material mat.
</p>

				
				
			

			
				
				<h3 id="Sphere.Intersect">func (*Sphere) <a href="/src/target/sphere.go?s=370:431#L10">Intersect</a>
					<a class="permalink" href="#Sphere.Intersect">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#Sphere">Sphere</a>) Intersect(ray <a href="#Ray3">Ray3</a>) (hit <a href="/pkg/builtin/#bool">bool</a>, dist <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Intersect tests whether the sphere intersects a given ray
</p>

				
				
				
			
				
				<h3 id="Sphere.MaterialAt">func (*Sphere) <a href="/src/target/sphere.go?s=1169:1216#L45">MaterialAt</a>
					<a class="permalink" href="#Sphere.MaterialAt">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#Sphere">Sphere</a>) MaterialAt(v <a href="#Vector3">Vector3</a>) <a href="#Material">Material</a></pre>
				<p>
MaterialAt returns the material at a given point on the surface
</p>

				
				
				
			
				
				<h3 id="Sphere.NormalAt">func (*Sphere) <a href="/src/target/sphere.go?s=963:1011#L38">NormalAt</a>
					<a class="permalink" href="#Sphere.NormalAt">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#Sphere">Sphere</a>) NormalAt(point <a href="#Vector3">Vector3</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
NormalAt returns the surface normal given a point on the surface
</p>

				
				
				
			
		
			
			
			<h2 id="Surface">type <a href="/src/target/surface.go?s=140:256#L1">Surface</a>
				<a class="permalink" href="#Surface">&#xb6;</a>
			</h2>
			<p>
Surface is an interface to all surface types (sphere, cube, etc)
A surface is anything that can be intersected by a Ray.
</p>

			<pre>type Surface interface {
    Intersect(<a href="#Ray3">Ray3</a>) (<a href="/pkg/builtin/#bool">bool</a>, <a href="/pkg/builtin/#float64">float64</a>)
    NormalAt(<a href="#Vector3">Vector3</a>) <a href="#Vector3">Vector3</a>
    MaterialAt(<a href="#Vector3">Vector3</a>) <a href="#Material">Material</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Vector3">type <a href="/src/target/vector3.go?s=71:111#L1">Vector3</a>
				<a class="permalink" href="#Vector3">&#xb6;</a>
			</h2>
			<p>
Vector3 holds x, y, z
</p>

			<pre>type Vector3 struct {
<span id="Vector3.X"></span>    X, Y, Z <a href="/pkg/builtin/#float64">float64</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="AngleVector">func <a href="/src/target/vector3.go?s=3088:3132#L98">AngleVector</a>
					<a class="permalink" href="#AngleVector">&#xb6;</a>
				</h3>
				<pre>func AngleVector(theta, phi <a href="/pkg/builtin/#float64">float64</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
AngleVector creates a vector based on theta and phi
</p>

				
				
			
				
				<h3 id="SphereVector">func <a href="/src/target/vector3.go?s=2911:2952#L93">SphereVector</a>
					<a class="permalink" href="#SphereVector">&#xb6;</a>
				</h3>
				<pre>func SphereVector(rnd *<a href="/pkg/math/rand/">rand</a>.<a href="/pkg/math/rand/#Rand">Rand</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
SphereVector returns a random unit vector (some point on the edge of a unit sphere)
</p>

				
				
			

			
				
				<h3 id="Vector3.Abs">func (Vector3) <a href="/src/target/vector3.go?s=4341:4371#L141">Abs</a>
					<a class="permalink" href="#Vector3.Abs">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Abs() <a href="#Vector3">Vector3</a></pre>
				<p>
Abs converts X, Y, and Z to absolute values
</p>

				
				
				
			
				
				<h3 id="Vector3.Array">func (Vector3) <a href="/src/target/vector3.go?s=1845:1880#L61">Array</a>
					<a class="permalink" href="#Vector3.Array">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Array() [3]<a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Array converts this Vector3 to a fixed Array of length 3
</p>

				
				
				
			
				
				<h3 id="Vector3.Ave">func (Vector3) <a href="/src/target/vector3.go?s=898:928#L31">Ave</a>
					<a class="permalink" href="#Vector3.Ave">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Ave() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Ave returns the average of X, Y, and Z
</p>

				
				
				
			
				
				<h3 id="Vector3.By">func (Vector3) <a href="/src/target/vector3.go?s=267:305#L9">By</a>
					<a class="permalink" href="#Vector3.By">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) By(b <a href="#Vector3">Vector3</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
By multiplies by a Vector3
</p>

				
				
				
			
				
				<h3 id="Vector3.Cone">func (Vector3) <a href="/src/target/vector3.go?s=1344:1403#L43">Cone</a>
					<a class="permalink" href="#Vector3.Cone">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Cone(size <a href="/pkg/builtin/#float64">float64</a>, rnd *<a href="/pkg/math/rand/">rand</a>.<a href="/pkg/math/rand/#Rand">Rand</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
Cone returns a random vector within a Cone of the original vector
size is 0-1, where 0 is the original vector and 1 is anything within the original hemisphere
<a href="https://github.com/fogleman/pt/blob/69e74a07b0af72f1601c64120a866d9a5f432e2f/pt/util.go#L24">https://github.com/fogleman/pt/blob/69e74a07b0af72f1601c64120a866d9a5f432e2f/pt/util.go#L24</a>
</p>

				
				
				
			
				
				<h3 id="Vector3.Cross">func (Vector3) <a href="/src/target/vector3.go?s=3289:3330#L103">Cross</a>
					<a class="permalink" href="#Vector3.Cross">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Cross(b <a href="#Vector3">Vector3</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
Cross returns the cross product of vectors a and b
</p>

				
				
				
			
				
				<h3 id="Vector3.Dot">func (Vector3) <a href="/src/target/vector3.go?s=2743:2782#L88">Dot</a>
					<a class="permalink" href="#Vector3.Dot">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Dot(b <a href="#Vector3">Vector3</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Dot returns the dot product of two vectors
(which is also the cosine of the angle between them)
</p>

				
				
				
			
				
				<h3 id="Vector3.Enters">func (Vector3) <a href="/src/target/vector3.go?s=2011:2050#L66">Enters</a>
					<a class="permalink" href="#Vector3.Enters">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Enters(b <a href="#Vector3">Vector3</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Enters returns whether this Vector is entering the plane represented by a normal Vector
</p>

				
				
				
			
				
				<h3 id="Vector3.Equals">func (Vector3) <a href="/src/target/vector3.go?s=4202:4241#L136">Equals</a>
					<a class="permalink" href="#Vector3.Equals">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Equals(b <a href="#Vector3">Vector3</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Equals compares two vectors
</p>

				
				
				
			
				
				<h3 id="Vector3.Len">func (Vector3) <a href="/src/target/vector3.go?s=3746:3776#L119">Len</a>
					<a class="permalink" href="#Vector3.Len">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Len() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Len finds the length of the vector
</p>

				
				
				
			
				
				<h3 id="Vector3.Lerp">func (Vector3) <a href="/src/target/vector3.go?s=3879:3930#L124">Lerp</a>
					<a class="permalink" href="#Vector3.Lerp">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Lerp(b <a href="#Vector3">Vector3</a>, n <a href="/pkg/builtin/#float64">float64</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
Lerp linearly interpolates between two vectors
</p>

				
				
				
			
				
				<h3 id="Vector3.Max">func (Vector3) <a href="/src/target/vector3.go?s=1006:1036#L36">Max</a>
					<a class="permalink" href="#Vector3.Max">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Max() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Max returns the highest of X, Y, and Z
</p>

				
				
				
			
				
				<h3 id="Vector3.Minus">func (Vector3) <a href="/src/target/vector3.go?s=3457:3498#L108">Minus</a>
					<a class="permalink" href="#Vector3.Minus">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Minus(b <a href="#Vector3">Vector3</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
Minus subtracts another vector from this one
</p>

				
				
				
			
				
				<h3 id="Vector3.Plus">func (Vector3) <a href="/src/target/vector3.go?s=391:431#L14">Plus</a>
					<a class="permalink" href="#Vector3.Plus">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Plus(b <a href="#Vector3">Vector3</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
Plus adds Vector3s together
</p>

				
				
				
			
				
				<h3 id="Vector3.RandHemiCos">func (Vector3) <a href="/src/target/vector3.go?s=2289:2341#L72">RandHemiCos</a>
					<a class="permalink" href="#Vector3.RandHemiCos">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) RandHemiCos(rnd *<a href="/pkg/math/rand/">rand</a>.<a href="/pkg/math/rand/#Rand">Rand</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
RandHemiCos returns a random unit vector sharing a hemisphere with this Vector with a cosine weighted distribution
<a href="https://github.com/fogleman/pt/blob/69e74a07b0af72f1601c64120a866d9a5f432e2f/pt/ray.go#L28">https://github.com/fogleman/pt/blob/69e74a07b0af72f1601c64120a866d9a5f432e2f/pt/ray.go#L28</a>
</p>

				
				
				
			
				
				<h3 id="Vector3.Reflected">func (Vector3) <a href="/src/target/vector3.go?s=4061:4106#L130">Reflected</a>
					<a class="permalink" href="#Vector3.Reflected">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Reflected(b <a href="#Vector3">Vector3</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
Reflected reflects the vector about a normal (b)
</p>

				
				
				
			
				
				<h3 id="Vector3.Refracted">func (Vector3) <a href="/src/target/vector3.go?s=566:643#L19">Refracted</a>
					<a class="permalink" href="#Vector3.Refracted">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Refracted(b <a href="#Vector3">Vector3</a>, indexA, indexB <a href="/pkg/builtin/#float64">float64</a>) (<a href="/pkg/builtin/#bool">bool</a>, <a href="#Vector3">Vector3</a>)</pre>
				<p>
Refracted refracts a vector based on the ratio of coefficients of refraction
</p>

				
				
				
			
				
				<h3 id="Vector3.Scaled">func (Vector3) <a href="/src/target/vector3.go?s=146:188#L4">Scaled</a>
					<a class="permalink" href="#Vector3.Scaled">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Scaled(n <a href="/pkg/builtin/#float64">float64</a>) <a href="#Vector3">Vector3</a></pre>
				<p>
Scaled multiplies by a scalar
</p>

				
				
				
			
				
				<h3 id="Vector3.Unit">func (Vector3) <a href="/src/target/vector3.go?s=3614:3645#L113">Unit</a>
					<a class="permalink" href="#Vector3.Unit">&#xb6;</a>
				</h3>
				<pre>func (a <a href="#Vector3">Vector3</a>) Unit() <a href="#Vector3">Vector3</a></pre>
				<p>
Unit returns the vector in the same direction of length 1
</p>

				
				
				
			
		
	

	





